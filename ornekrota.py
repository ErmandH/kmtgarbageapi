# -*- coding: utf-8 -*-
"""kmt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10DftjrZhbNs4Vp-MsnmMj2m33i3NDPPk
"""

#KÃ¼tÃ¼phaneleri kur
!pip install -q ortools googlemaps folium

#Gerekli kÃ¼tÃ¼phaneleri iÃ§e aktar
import googlemaps
import numpy as np
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
import folium
import time

#GOOGLE MAPS API ANAHTARI
API_KEY = "AIzaSyBdgY41Sei78WfYhBpIL2eDGHJzNDof_ks"
gmaps = googlemaps.Client(key=API_KEY)

#LOKASYONLAR (Depo + Konteynerler)
locations = {
    "Depo": (40.9765, 28.8706),
    "Kon1": (40.9741, 28.8754),
    "Kon2": (40.9753, 28.8722),
    "Kon3": (40.9732, 28.8709),
    "Kon4": (40.9737, 28.8681),
    "Kon5": (40.9744, 28.8692),
    "Kon6": (40.9762, 28.8686),
    "Kon7": (40.9768, 28.8710),
    "Kon8": (40.9751, 28.8734),
    "Kon9": (40.9748, 28.8748),
    "Kon10": (40.9738, 28.8729),
}

location_names = list(locations.keys())
coords = list(locations.values())

# MESAFE + TRAFÄ°KLÄ° SÃœRE MATRÄ°SÄ° VE AÄžIRLIKLI MALÄ°YET
def create_weighted_cost_matrix(locations, alpha=0.7, beta=0.3):
    size = len(locations)
    distance_matrix = np.zeros((size, size))
    duration_matrix = np.zeros((size, size))

    for i in range(size):
        origins = [locations[i]]
        destinations = locations
        response = gmaps.distance_matrix(
            origins,
            destinations,
            mode='driving',
            departure_time='now'  # anlÄ±k trafik
        )

        for j in range(size):
            try:
                distance_km = response['rows'][0]['elements'][j]['distance']['value'] / 1000
                duration_min = response['rows'][0]['elements'][j]['duration_in_traffic']['value'] / 60

                distance_matrix[i][j] = distance_km
                duration_matrix[i][j] = duration_min
            except:
                distance_matrix[i][j] = 99999
                duration_matrix[i][j] = 99999

        time.sleep(1)

    cost_matrix = alpha * distance_matrix + beta * duration_matrix
    return cost_matrix, distance_matrix, duration_matrix

# MATRÄ°SLERÄ° OLUÅžTUR
print("Maliyet matrisleri oluÅŸturuluyor...")
cost_matrix, distance_matrix, duration_matrix = create_weighted_cost_matrix(coords, alpha=0.7, beta=0.3)
print("Maliyet matrisleri oluÅŸturuldu.")

# ROTA OPTÄ°MÄ°ZASYONU
def solve_tsp_returning_route(cost_matrix, distance_matrix, duration_matrix):
    manager = pywrapcp.RoutingIndexManager(len(cost_matrix), 1, 0)
    routing = pywrapcp.RoutingModel(manager)

    def cost_callback(from_index, to_index):
        return int(cost_matrix[manager.IndexToNode(from_index)][manager.IndexToNode(to_index)] * 1000)

    transit_callback_index = routing.RegisterTransitCallback(cost_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)

    solution = routing.SolveWithParameters(search_parameters)

    if solution:
        print("Optimal rota:")
        index = routing.Start(0)
        route = []
        total_distance = 0
        total_duration = 0
        while not routing.IsEnd(index):
            node_index = manager.IndexToNode(index)
            route.append(location_names[node_index])
            next_index = solution.Value(routing.NextVar(index))

            from_node = manager.IndexToNode(index)
            to_node = manager.IndexToNode(next_index)

            total_distance += distance_matrix[from_node][to_node]
            total_duration += duration_matrix[from_node][to_node]

            index = next_index

        route.append(location_names[manager.IndexToNode(index)])

        print(" âž¡ ".join(route))
        print(f"Toplam mesafe: {total_distance:.2f} km")
        print(f"Toplam tahmini sÃ¼re (trafikli): {total_duration:.1f} dakika")
        return route
    else:
        print("Ã‡Ã¶zÃ¼m bulunamadÄ±.")
        return []

# ROTA HESAPLA
route = solve_tsp_returning_route(cost_matrix, distance_matrix, duration_matrix)

from folium.plugins import PolyLineTextPath  # Bu satÄ±rÄ± en Ã¼stte import etmeyi unutma

# HARÄ°TA OLUÅžTUR (Daha gÃ¶rsel hale getirildi)
map_center = coords[0]
m = folium.Map(location=map_center, zoom_start=15)

route_coords = [locations[name] for name in route]

# Marker'larÄ± sÄ±rayla ekle
for i, (name, coord) in enumerate(zip(route, route_coords)):
    if name == "Depo":
        # Depo iÃ§in Ã¶zel ikon (kÄ±rmÄ±zÄ± kamyon)
        folium.Marker(
            location=coord,
            popup="ðŸŸ¥ 1. Depo (BaÅŸlangÄ±Ã§)",
            tooltip="Depo",
            icon=folium.Icon(color="red", icon="truck", prefix="fa")
        ).add_to(m)
    else:
        folium.Marker(
            location=coord,
            popup=f"{i+1}. {name}",
            tooltip=f"{i+1}. {name}",
            icon=folium.Icon(color="blue", icon="trash", prefix="fa")
        ).add_to(m)

# Rota Ã§izgisi
line = folium.PolyLine(route_coords, color="blue", weight=4, opacity=0.7).add_to(m)

# YÃ¶n oklarÄ± ekle
arrowed = PolyLineTextPath(
    line,
    '  â–¶  ',  # ok sembolÃ¼
    repeat=True,
    offset=10,
    attributes={
        'fill': 'blue',
        'font-weight': 'bold',
        'font-size': '14'
    }
)
m.add_child(arrowed)

# HaritayÄ± kaydet
m.save("rota_haritasi.html")
m
